# 概要

本章では、ボリュームを使ったデータの永続化を学んでいきます。

コンテナ/ホスト間でアプリケーションに必要なデータを受け渡しできれば、特定の開発環境に特化した
より便利なコンテナをつくれるようになります。

## 本章のゴール

* ホスト・コンテナ間でデータをやりとりするための方法を学ぶ

* bind mountの概要の理解
→ ホストでつくったPHPファイルをコンテナで動かすことを目指します。  

* docker volumeコマンドの基本操作の習得
* volumesによるマウントの習得
→ コンテナでつくったデータベースのバックアップを、別のコンテナでリストアすることを目指します。


## ボリュームとは

ボリューム周りの用語は、私自身迷子になったところなので、最初に補足します。
詳細は以降に譲りますが、まずそれぞれの用語の概略を押さえておくことで、迷ったときにも整理できるようにしておきましょう。

* volume: `docker volume`コマンドで操作されるDockerエンジンが管理する領域
* volumes: `docker volume`コマンドを使ったデータ永続化手法
* bind mount: volumesとはマウント元が異なるデータ永続化手法


ボリュームについて、[公式](https://docs.docker.com/storage/volumes/)で

> Volumes are the preferred mechanism for persisting data generated by and used by Docker containers.

と言及されています。「Dockerコンテナで使われるデータ永続化のための機構」といった意味ですが、これだけでは実体が見えてきませんね。
非常に混乱しやすいところなのですが、上の定義は「docker volume documentation」で検索して表示される公式ドキュメントに書かれているものではあります。
しかし、どうやらボリュームのことは指していないようです。
実際は、「volumes」と呼ばれる、ボリューム使ったデータ永続化方法の定義を記述しており、Dockerの用語では、「volume・volumes」が区別されています。

ボリュームは、単体で考えるととても迷いやすいので、周辺の用語と関連付けていくと、少しは見えやすくなるかと思います。
ホストとコンテナでファイルをやりとりする例をいくつか見た後で、もう一度定義を考えてみることにしましょう。

### mountとは

ここからは、データをやり取りする上で、マウントの話が増えてくるので、少し復習しましょう。

まずは単語自体の意味を確認しておきます。
mountは、「登る・上に乗る」といった意味を持ちます。動物のマウンティングをイメージしてみるとよいかもしれません。

続いて、Linuxコマンドのmountを考えてみます。
mountコマンドは、ディレクトリツリーへデバイス上のファイルシステムを接続するために使われます。
このとき、マウント元は、マウント先のディレクトリの「上に覆いかぶさる」ような動作をとります。
名前と動きが対応していることが掴めれば、以降でマウントの話が出たときにも迷子にならずに済むかと思います。

[参考](https://man7.org/linux/man-pages/man8/mount.8.html)


## bind mount

マウントを簡単に復習したので、[bind mount](https://docs.docker.com/storage/bind-mounts/)を見ていきましょう。
bind mountは、Dockerコンテナへファイルやディレクトリをマウントする手法の一つです。
ここで、重要なのは、マウント元がホストマシンであることです。
ホストのファイルを渡せることから、アプリのソースコードや設定ファイルなど、開発で頻繁に書き換えられる
ファイルをコンテナで参照したいときに有用です。

bind mountにより、ホストマシン・コンテナ間でデータがどのように連携されるのか、追っていきましょう。

### bind mountまでの流れ

コンテナへファイル/ディレクトリをマウントするには、いくつか準備が要ります。
準備の間にbind mountを見失わないよう、最初に簡単に流れを押さえておきます。
大まかな流れは次の通りです。

* ホスト上でコンテナへ渡したいファイル/ディレクトリを作成
* イメージを取得
* コンテナを作成←`docker container create`コマンドのオプションでマウントの設定を指定!!
* コンテナを起動
* コンテナの中に入り、マウントされたファイル/ディレクトリを操作

ゴールとして、ホストでつくったPHPファイルをコンテナ上で動かすことを目指します。
流れに沿って、手を動かしていきましょう。

### PHPファイルの作成

最初に、コンテナへマウントするディレクトリ・PHPファイルをつくります。
マウントすることが目的なので、PHPファイルは挨拶するだけの簡素なものとしておきます。

今回は、`source`ディレクトリ配下で、`hello.php`を書いておきます。

```bash
$ mkdir source
```

```PHP
// source/hello.php
<?php
echo 'Hello PHP from bind mount!!' . PHP_EOL;
```

つくったファイルをコンテナで動かすために、bind mountを使っていきます。

### PHPイメージの取得

前章では、UbuntuのイメージをもとにつくったコンテナへPHPをインストールしました。
コンテナの中に入ったときの操作に慣れることを目的としていたので、少し遠回りに感じたかもしれません。
ただPHPを実行するだけであれば、公式イメージに頼るのが便利で早くて安心です。

以降はWebサーバを動かしたり、データベースと組み合わせたりと、徐々にコンテナが複雑になっていきます。
コンテナ関連のあれこれを理解することに集中できるよう、これからは公式イメージの力を借りていきましょう。

---

ということで、PHPのイメージを手に入れましょう。
タグはお好みのもので問題ありませんが、とりあえず、`8.0-buster`を指定しておきます。
また、busterは、Ubuntuの元となったDebianのバージョン10へつけられたコードネームを指すようです。

[参考](https://www.debian.org/releases/buster/)

```bash
# イメージの取得
$ docker image pull php:8.0-buster
8.0-buster: Pulling from library/php
69692152171a: Pull complete 
# 中略...
Digest: sha256:1942f4046bbc358c3ad2e157db8341f95fb72673c76fd6b2e1c3fe429eb3dce9
Status: Downloaded newer image for php:8.0-buster
docker.io/library/php:8.0-buster

# イメージの確認
$ docker image ls
REPOSITORY   TAG          IMAGE ID       CREATED       SIZE
php          8.0-buster   a868b8546a9e   2 weeks ago   423MB
```

### コンテナの作成とbind mount

続いて、イメージからコンテナをつくっていきます。
そして、コンテナをつくるときに、いよいよbind mountの設定を書くことになります。

bind mountは、コンテナをつくるときに、`docker container create ... --mount <key>=<value>`
のように記述します。
前の章では、`-i`, `-t`オプションにより、コンテナの標準入出力・端末に関する振る舞いを制御しました。
本章では、`--mount`オプションでマウントの振る舞いを決めていきます。

#### mountオプションの記法

mountオプションは、`<key>=<value>`のキーバリューペア形式で書くことができ、
マウント方法・マウント元・マウント先などを指定します。
主に使うキーを見てみましょう。

* type: マウント方法 bind, volumeを主に指定
* source: マウント元 bindマウントではホストのファイルやディレクトリを指定
* destination: マウント先 コンテナ内のパスを指定 targetキーでも同様の動作をする

これらを組み合わせれば、「コンテナのどのパスへ(destination)、どこからのファイル/ディレクトリを(source)どのようにマウントするか(type)」を
表現できます。

[参考](https://docs.docker.com/storage/bind-mounts/#choose-the--v-or---mount-flag)

#### いざbind mount

オプションの概要が見えてきたところで、今度こそbind mountを試してみましょう。

```bash
# --mountフラグを指定してコンテナを作成
$ docker container create -it --mount type=bind,source="$PWD"/source,destination=/home/source --name php php:8.0-buster
9d9f1390780e93f36fa3e9375f470271ff788ecf433a1a328dd74db12e1970b3
```

mountオプションに注目します。
オプションの意味を実例に沿って書き下してみると、
「bind mountを使って、ホストの`カレントディレクトリ/source`ディレクトリをコンテナの`/home/source`ディレクトリへマウントしてね」
といった具合になります。

概念は少し取っつきづらいですが、命令はとてもシンプルですね。
本当にホストのディレクトリがコンテナへマウントされたのか、コンテナの中に入って確かめてみましょう。

```bash
# コンテナを起動
$ docker container start php
php
# コンテナの中へ
$ docker container exec -it php bash

# マウントされたディレクトリ・ファイルが存在するか確認
root@9d9f1390780e:/# cd /home/source
root@9d9f1390780e:/home/source# ls
hello.php
```

コンテナ上でシェルを対話モードで起動し、`/home/source`ディレクトリを覗いてみました。
狙い通り、マウント元のディレクトリと、その中身である`hello.php`がマウントされたことが確認できました。

ついでに、あいさつがてらマウントされたPHPファイルを動かしてみます。

```bash
# PHPのバージョンを確認
root@9d9f1390780e:/# php --version
PHP 8.0.6 (cli) (built: May 12 2021 12:47:05) ( NTS )
Copyright (c) The PHP Group
Zend Engine v4.0.6, Copyright (c) Zend Technologies

# PHPファイルを実行
root@9d9f1390780e:/home/source# php -f ./hello.php 
# 出力
Hello PHP from bind mount!!
```

ホストでつくったファイルをコンテナの中で動かせました。
これで、bind mountの動きをざっくりと見ることができました。

#### 補足: なぜコンテナの中でファイルをつくらないのか

bind mountを使えば、ホストからコンテナへファイルを渡せることが分かりました。
しかし、マウントを理解したり、長ったらしい設定を書いたりしなくとも、コンテナの中で
ファイルをつくってしまえば、もっと楽なように思えます。

ここで、コンテナが使い捨てであることを思い出してみましょう。
使い捨てであるからこそ、実行環境のバージョンを変えたいときにも簡単に対応できます。

コンテナをすぐに使う/捨てるためには、別のコンテナでも使いたいファイルを「外部」へ切り離す必要があります。
これを実現してくれるのが、ボリューム(bind mount)なのです。


#### 後片付け

bind mountを一通り試せたので、後片付けをしておきます。

```bash
# コンテナを停止・削除
$ docker container stop php
php
$ docker container rm php
php
```

以降では、コンテナへファイル/ディレクトリをマウントする別のやり方として、volumesを見ていきます。

#### 補足: vフラグ

Dockerの書籍や記事では、`--mount`フラグの代わりに、`-v`フラグを見ることが多いかもしれません。
元々は`-v`フラグが使われており、より直感的に分かりやすくするため、`--mount`フラグが導入されました。
公式いわく、

> New users should use the --mount syntax.

とあるので、`--mount`フラグが推奨されているようです。
両者の違いは、`--mount`フラグは見た目でbind mount, volumes(後述)を区別しやすい・
`--mount`フラグはsourceに指定したものが存在しなかった場合、新たにつくるのではなくエラーと判定、
といったところにあります。

これからは`--mount`フラグを使えば良いんだな〜、 ぐらいの理解で問題ないと思います。

[参考](https://docs.docker.com/storage/bind-mounts/#choose-the--v-or---mount-flag)

#### 補足: なぜbindという名前なのか

bind mountの名前について少し考えてみましょう。
英単語の「bind」には、束縛する、といった意味があります。
これまでの動きを見る限りでは、何かを束縛している様子はありませんでした。bindとは、一体何を指しているのでしょうか。

これは、「ホストのディレクトリ・ファイルを対象とすること」を表しています。
マウント元にホストマシンの特定のパスを指定した場合、特定のOS(Windows, Linux, ...)へ依存することになります。

後述するvolumesによるマウントと比べると、ホストマシンへ束縛されていることから、
「bind」という名前を使うようになったのではないかと思います。

[参考](https://docs.docker.com/storage/volumes/)


## volumes

続いて、bind mountとは対比してとりあげられるvolumesを触っていきます。
volumesを一言で表すと、`docker volume`コマンドで操作されるものを利用したマウント手法です。

bind mountはマウント元として、ホスト上の特定のパスを指定しました。
一方、volumesは、Dockerエンジンの管理する領域がマウント元となります。
より具体的には、マウント元を`docker volume`コマンドで制御できるようになります。

よくある用途として、データベースのバックアップを保管しておき、別のコンテナでリストアしたいときに使うと便利です。

---

### 試してみる

少し実践的な例として、volumesを使ったデータベースのバックアップ・リストアを試してみます。
最初に、全体像を掴むためにやることを整理しておきます。`docker volume`コマンドにより、別のコンテナへ
データベースを移動させることを目標とします。

※ DBMSは何でもよいですが、今回は個人的に操作しやすいかなと思うPostgreSQLを採用します。

大まかな手順は、以下のようになります。

* ボリュームを作成
* ボリュームをコンテナへマウント
* マウント先のコンテナで、データベースのテーブル・レコードを作成→バックアップファイルをマウント先へ配置
* コンテナを破棄
  
* 新たにコンテナを作成し、上で使用したボリュームをマウント
* マウント先のコンテナでバックアップからデータベースをリストア
* 最初のコンテナで作成したテーブル・レコードが参照できることを確認
* コンテナ・ボリュームを破棄

`docker volume`コマンドを身につけることを目指して、やってみましょう。

#### ボリュームの作成

まずは、ボリュームをつくるところから始めます。
ボリュームは、`docker volume create`コマンドでつくることができます。

> 書式: `docker volume create [OPTIONS] [VOLUME]`

オプションはボリュームを細かく制御したいときに指定しますが、今回は割愛します。
つまり、ただボリュームを使いたいだけであれば、`docker volume create <ボリューム名>`で事足ります。

書式に従い、ボリュームをつくってみましょう。ボリューム名は、`postgres_db`とします。

```bash
$ docker volume create postgres_db
# 出力
postgres_db
```

ちゃんとつくれたのかどうか、確認しておきましょう。
ボリュームの一覧は、イメージやコンテナと同様に、`docker volume ls`コマンドで見ることができます。

>書式: `docker volume ls [OPTIONS]`

オプションには、ボリュームの表示方法・対象などを指定します。
少数のボリュームを扱うのであれば、オプションなしでも十分でしょう。

```bash
# 出力
$ docker volume ls
DRIVER    VOLUME NAME
local     postgres_db
```

`docker volume ls`コマンドにより、ボリュームをつくれたことが確認できました。
以降では、このボリュームを使って、複数コンテナ間のデータのやり取りを試してみましょう。

#### 補足: DRIVERフィールド

`docker volume ls`コマンドの表示項目のうち、DRIVERフィールドは少し補足が必要です。
localはデフォルトの値で、ローカルのファイルシステム上にボリュームが存在することを表しています。

他に取り得る値には、ネットワーク上のさまざまなサービスのファイルシステムがあります。
これらはプラグインが提供されており、ローカルにネットワーク上のファイルシステムをマウントすることなく、Dockerの閉じた世界で
ボリュームを完結させることができます。

[参考](https://docs.docker.com/engine/extend/legacy_plugins/#volume-plugins)

また、ここでの「driver」という単語は、データをやり取りするためのものを表しています。
ですので、いまいちイメージが掴みづらいと思ったときには、とりあえずDRIVERフィールドには、どうやってボリュームとコンテナが
データをやりとりするかが書かれているんだな〜、ぐらいの理解で大丈夫です。

---

#### ボリュームをコンテナへマウント

続いて、ボリュームをマウントし、データベースを操作していくコンテナをつくります。
前準備として、PostgreSQLのイメージを手に入れておきます。
イメージ名はpostgresで、タグは「13-buster」を選びます。

```bash
$ docker image pull postgres:13-buster
# 出力
13-buster: Pulling from library/postgres
# ...中略
Digest: sha256:d28e2df4582de09c99c85d74615e3f857b3bb6fb3d336eaa22430865cb9e08cb
Status: Downloaded newer image for postgres:13-buster
docker.io/library/postgres:13-buster
```

そして、bind mountのときと同じように、コンテナの作成時にマウントオプションで、つくったボリュームを指定します。
bind mountとの違いは、typeキーへ`volume`(volumesによるマウントであること)を・sourceへボリューム名を記述することです。

それさえ押さえておけば、つくったボリュームをコンテナの「/home/backup」ディレクトリへマウントするんだな〜、ということが理解できるはずです。

```bash
# volumesによ るマウントでコンテナを作成
$ docker container create -it --mount type=volume,source=postgres_db,target=/home/backup --name postgres -e POSTGRES_PASSWORD=mysecretpassword postgres:13-buster
6b9c04479041fbc1c0de3a22aae8ed21d797c04fae83d7c45334e05aab39be8d
```

また、コンテナをつくるときのオプションについて、補足を加えておきます。
`-e`オプションは、コンテナ内の環境変数(environment variable)をキー・バリュー形式で記述します。
データベースを操作するにはログインしなければならないので、素敵なパスワードを指定しておきましょう。

※1 よろしくないことですが、ボリュームのマウントに集中するため、パスワードはベタ書きで済ませています。
※2 また、POSTGRES_PASSWORD環境変数は、省略してしまうとデータベースの起動チェックに引っかかるようです。

---

#### データベースの操作

少し長くなりましたが、コンテナもできあがったので、コンテナの中に入って、ボリュームへ渡すための
データベースをつくりあげていきましょう。
最初のステップとして、コンテナへ入ることから始めます。

```bash
$ docker container start postgres
postgres
$ docker container exec -it postgres bash

# ボリュームがマウントされることで、/home/backupディレクトリが作成されたことを確認
root@6b9c04479041:/# cd /home/backup/
root@6b9c04479041:/home/backup#
```

ボリュームがマウントされているようなので、さらっとデータベースを変更してから、別のコンテナへ受け渡すバックアップを
つくっていきます。
少しPostgreSQLの操作が絡みますが、各コマンドには簡単にコメントを書いておいたので、PostgreSQLに触れたことのない方は
流し読みしちゃってください。

```bash
# postgreSQLのデフォルトDBへpostgresユーザでログイン パスワードは環境変数から読み取り
root@6b9c04479041:/# psql -U postgres
psql (13.3 (Debian 13.3-1.pgdg100+1))
Type "help" for help.

# お試しでユーザテーブルを作成
postgres=# create table sample_user(user_name varchar(255));
CREATE TABLE
# dockerという名前のユーザレコードをつくってみる
postgres=# insert into sample_user(user_name) values('docker');
INSERT 0 1
# テーブルへレコードが作成されたことを確認
postgres=# select * from sample_user;
 user_name 
-----------
 docker
(1 row)
```

ようやく準備が整ったので、ボリュームがマウントされたディレクトリへバックアップファイルを出力します。

```bash
# pg_dumpコマンドでユーザ名・データベース名を明示してバックアップを作成
root@6b9c04479041:/home/backup# pg_dump -U postgres  postgres > db_backup.dump
# マウント先のディレクトリへバックアップが作成されたことを確認
root@6b9c04479041:/home/backup# ls
db_backup.dump
# コンテナから脱出
root@6b9c04479041:/home/backup# exit
exit
```

コンテナを破棄し、別のコンテナをつくり直してもボリュームが保存されているか確認するため、後片付けをしておきましょう。

```bash
# コンテナの停止・破棄
$ docker container stop postgres
postgres
$ docker container rm postgres
postgres
```

#### volumesによるマウントで、別のコンテナへデータベースをリストアできるか

念のため、コンテナが消えてもボリュームが残ってくれているか、見ておきましょう。

```bash
$ docker volume ls
DRIVER    VOLUME NAME
# 見覚えのないボリュームがつくられている
local     d47a40ae24f83914d73d314f02251116513e80c48d71098c65b01b3dd5052b33
local     postgres_db
```

ボリュームは残っていましたが、何やら見覚えのないボリュームがつくられています。
このボリュームを解き明かすには、少し込み入った説明が要るので、volumesを一通り触ったあとの補足へ譲ることにします。

---

さて、bind mountと同じように、別のコンテナへボリュームをマウントするとデータが復元できるのか、確かめてみましょう。
手順はほぼ同じなので、コンテナの中に入るまでは一気に進めます。


```bash
# 上でつくったコンテナと記述はほぼ同じ 名称のみ変更しておく
$ docker container create -it --mount type=volume,source=postgres_db,target=/home/backup --name postgres_restore -e POSTGRES_PASSWORD=mysecretpassword postgres:13-buster postgres
808254496bfc12d7ebee327cfc599bc529185e0b1f4c08e54da4588de598d6eb
$ docker container start postgres_restore
postgres_restore

$ docker container exec -it postgres_restore bash
root@808254496bfc:/# cd /home/backup/

# バックアップファイルがマウントされていることを確認
root@808254496bfc:/home/backup# ls
db_backup.dump
```

バックアップファイルが無事にマウントされていたようです。
中身を確かめるまでは安心できないので、リストアしてテーブルの中身を調べてみます。

```bash
# バックアップファイルからデータベースをリストア
root@808254496bfc:/home/backup# psql -U postgres postgres < ./db_backup.dump
SET
# ...中略
CREATE TABLE
ALTER TABLE
COPY 1

# データベースへログイン
root@808254496bfc:/home/backup# psql -U postgres
psql (13.3 (Debian 13.3-1.pgdg100+1))
Type "help" for help.

# 別のコンテナでつくったテーブルのレコードを参照できたことを確認
postgres=# select * from sample_user;
 user_name 
-----------
 docker
(1 row)
```

ついにゴールにたどり着けました。
実際にvolumesの仕組みでマウントしてみることで、ホスト・コンテナ間でのデータのやり取りの流れが少しでも掴めたのではないかと思います。

最後に、コンテナの後片付けをしておきましょう。

```bash
postgres=# exit
root@808254496bfc:/home/backup# exit
exit

# コンテナの停止・破棄
$ docker container stop postgres_restore
postgres_restore
$ docker container rm postgres_restore
postgres_restore
```

残りのステップにボリュームを削除することがありますが、取り残していた謎のボリュームについて解き明かしておきたいので、
補足へ委ねることにします。

#### 補足: なぜpostgreSQLのコンテナをつくると見覚えのないボリュームがつくられるのか

復習のため、ボリュームの一覧を再掲します。

```bash
$ docker volume ls
DRIVER    VOLUME NAME
# 見覚えのないボリュームがつくられている
local     d47a40ae24f83914d73d314f02251116513e80c48d71098c65b01b3dd5052b33
local     postgres_db
```

イメージやコンテナのIDのような名称のボリュームは、Dockerでは「匿名ボリューム」と呼ばれています。
匿名ボリュームをつくるような指示は書いていませんでしたが、何の理由もなくつくられたわけではありません。
少し考えてみましょう。

今回、postgreSQLのコンテナをつくったときに匿名ボリュームがつくられるようになりました。
他のコンテナではつくられていないようなので、postgreSQLのイメージに何か秘密がありそうです。

本章の範囲から逸れるため、詳細は割愛しますが、postgreSQLのイメージは、イメージをつくるときに、ボリュームの情報を指定しています。
このとき、マウント先は「/var/lib/postgresql/data」ディレクトリとなっています。
このディレクトリに関するマウント情報がない場合、postgreSQLのイメージからコンテナをつくると、匿名ボリュームができあがるようになっていました。

[参考](https://github.com/docker-library/postgres/blob/517c64f87e6661366b415df3f2273c76cea428b0/13/buster/Dockerfile)

これだけでは本当か分からないので、上記ディレクトリをマウント先に指定したボリュームをマウントした
コンテナをつくってみた様子を載せておきます。
コンテナ作成後の`docker volume ls`コマンドの様子から、匿名ボリュームがつくられなかったことが確認できるかと思います。

```bash
# バックアップ/データベースのデータ用のボリュームをそれぞれ作成
$ docker volume create postgres_backup
postgres_backup
$ docker volume create postgres_data  
postgres_data
$ docker volume ls
DRIVER    VOLUME NAME
local     postgres_backup
local     postgres_data

# バックアップ先だけでなく、データベースのデータもマウント先に指定してコンテナを作成/起動
$ docker container create -it -e POSTGRES_PASSWORD=password --mount type=volume,source=postgres_backup,target=/home/backup --mount type=volume,source=postgres_data,target=/var/lib/postgresql/data --name postgres postgres:13-buster postgres
e990ff2083872f63e266fe64cf5a022484d2d8078d71cb1bb8ddd61ab5c7dca6
$ docker container start postgres
postgres

# イメージのボリューム設定が反映されていることから、匿名ボリュームがはつくられなかった
$ docker volume ls
DRIVER    VOLUME NAME
local     postgres_backup
local     postgres_data
```


#### 補足: volumesという名前はどこからきたのか

公式では、ボリュームの定義っぽい記述の直後に、「volumes」とbind mountを比べています。
ボリュームに関するページですし、直前にボリュームの定義っぽいことも書かれているので、bind mountと
比較されているものがボリュームであるように思えます。

しかし、[用語集](https://docs.docker.com/glossary/#volume)を覗いてみると、`A volume`と`volumes`を
明確に区別しています。
改めて言語化すると、volumesがbind mountとあわせて語られる、コンテナへファイルやディレクトリをマウントするための手法。
一方、volumeは、`docker volume`コマンドによって操作される、Dockerエンジンが管理する領域。といった感じでしょうか。

bind mountと対比されるマウント手法をvolumeと呼ぶと、volumeによってvolumeが操作されることになり、ややこしくなるので、
このように区別されたのではないかと思います。
(どうせならvolume mountと銘打ってくれた方が、すっきりイメージできた気がしないでもないです...。)

[参考](https://docs.docker.com/storage/volumes/)

#### 補足:`docker volume`コマンドで扱えると何がうれしいのか

volumesは主に、コンテナ上のデータのバックアップなどで使われます。
バックアップしたいものはホストのどこにあっても構いませんが、どこでも良いからこそ、置き場所に悩むものです。
そんなときに、`docker volume`コマンドでつくってしまえば、ホストのどこに置くかなど、
ホストのことを考える必要がなくなります。

言い換えれば、ホストへの依存が抑えられるのです。


## volume再考

長くなってしまいましたが、bind mount, volumesによるマウントの流れを追うことができました。
ここで、本章の総仕上げとして、最初に見たボリューム周りの用語の定義について、もう少し詳しく書いてみます。

手を動かしたあとであれば、きっとイメージが掴めるはずです。

* bind mount: マウント元がホストの特定のパスであるマウント手法
→ アプリケーションのソースコードや設定ファイルなど、ホストで頻繁に変更されるようなファイルをコンテナへ渡したいときに有用。
  
* volumes: `docker volume`コマンドを使ったデータ永続化手法
→ bind mountとは異なり、マウント元がDockerエンジンにより隠蔽される。「コンテナの中でつくられたファイル」を別のコンテナへ受け渡したいときに便利。
  
* volume: `docker volume`コマンドで操作されるDockerエンジンが管理する領域
→ volumesによるマウントで操作される領域。どこに実体が存在するか意識する必要がなく、かつ、`docker volume`コマンドで操作できるため、コンテナとのデータのやり取りに便利。


## まとめ

本章では、ボリュームを使ったコンテナのデータの永続化を見ていきました。
コンテナへデータを渡したり、コンテナからデータを受け取ったりすることができるようになれば、より進化/再利用しやすいコンテナが
つくれるようになるはずです。

また、ボリューム周りは用語が特に混乱しやすいところなので、迷子になってしまったときは、言葉の定義を掘り下げたり、
実際に手を動かしてみたり、色々試してみてください。