# 概要

本演習では、正規表現の簡単な使い方をgrepコマンドで学んでいきます。
※ grepコマンドの詳細な使い方はまた別でとりあげます。

間違いなどございましたら、IssueやPRを頂けるとうれしいです。

[grep参考](https://linux.die.net/man/1/grep)
[正規表現参考](https://www.pcre.org/current/doc/html/pcre2syntax.html)
[正規表現参考書籍](https://twitter.com/arinoth/status/1306222992393863175)

## 対象読者

正規表現の基本は本とかでなんとなく理解したけれど、実際に使うときに手が止まる...。
といった方に実際に手を動かして頂くと、正規表現の理解が少し進むかもしれません。

# 問題

## 1. 郵便番号

「postalCode.txt」から郵便番号(数字三桁ハイフン数字四桁)形式を満たしているものを
grepコマンドで出力してください。

<details>
<summary>例・解説</summary>

### 例

```bash
$ grep -P "^\d{3}-\d{4}$" ./postalCode.txt 
# 出力
123-4567
555-5555
```

grepコマンドの基本記法は、`grep [OPTIONS] PATTERN [FILE...]`です。
各要素を順に見ていきましょう。

### OPTIONS

パターンを解釈する正規表現の種類・出力結果の制御方法などを指定します。
例では、「P(Perl regular expression)」オプションで、Perl互換の正規表現を選択しました。

### PATTERN

単純な等値比較など、正規表現以外の比較も記述できますが、正規表現を使いこなすことを目指すため、
正規表現のみを取りあげていきます。

### FILE

「...」で記述されているので、検索対象のファイルを複数指定することができます。

---

grepコマンドの出力結果は、パターンに合致した「行」となるので、正しく郵便番号形式となっていた
行のみが表示されます。

以降では、正規表現をより深く理解するため、今回学んだgrepコマンドの記法をベースに、いろいろな
パターンを見ていきます。

### コマンド再考

grepコマンドの基本記法が理解できたか再確認するため、実行したコマンドを見返してみます。
`grep -P "^\d{3}-\d{4}$" ./postalCode.txt `は、Perl互換の正規表現により、「postalCode.txt」ファイルを対象に、
行単位でパターンマッチングを実行します。
マッチ条件は、「先頭が数値3桁で始まり(`^\d{3}`)、ハイフンを挟んで、数値4桁で終わる行(`\d{4}$`)」となっています。

これにより、郵便番号形式の行のみを取得することができます。

</details>

## 2. 入力チェック(文字数)

「userID.txt」から、文字数が「5文字以上10文字以下」を満たすものを
grepコマンドで出力してください。


<details>
<summary>例・解説</summary>

### 例

```bash
$ grep -P "^.{5,10}$" ./userID.txt 
# 出力
pompom
1000000000

# 備考: 「ユーザ12」は出力されない
```

例では、ユーザIDの文字数チェックっぽいことをしています。
ポイントとなるのは、`{}`で、量指定子(quantifier)と呼ばれています。
括弧内には繰り返し回数が記述され、次のルールに従います。

* {n}→n回
* {n,m}→n回以上m回以下
* {n,}→n回以上

「以上」の表記は、下限のみで上限が無いと捉えると理解しやすくなるかもしれません。

そして、`.`は任意の一文字を表しているので、量指定子と組み合わせることで、文字数の判定ができます。

#### 補足: 日本語の文字数について

今回の例は、「5文字以上10文字以下」の文字列を対象としていましたが、「ユーザ12」という文字列は
対象となりませんでした。
直感的には5文字であるように見えるのに、なぜでしょうか。

---

これは、マルチバイト文字列の文字数がバイト数となっていることによります。
具体的には、日本語は「3バイト」文字列として扱われています。
裏付けをとるために、実験してみましょう。

```bash
# 最初の3文字を表示
$ grep -Po "^..." ./userID.txt 
pom
ver
100
use
# 「ユ」1文字が表示された
ユ
```

grepコマンドで見てみると、確かに日本語は3バイトで扱われているようでした。

---

(補足)
grepコマンドでよしなに日本語を扱う方法を調べてみましたが、いまいちしっくり来るものが
見当たりませんでした。
もし良い資料をご存知でしたら、IssueやPRを頂けるとよろこびます。


### コマンド再考

`grep -P "^.{5,10}$" ./userID.txt `コマンドを見返してみます。

「userID.txt」を対象に、Perl互換の正規表現で指定したパターンに合致するか検証します。
パターンは、「任意の文字による、5回以上10回未満の繰り返し」を表しています。

</details>


## 3. 変数名(文字種)

「variable.txt」から、シェルスクリプトの変数名として有効なもの(後述)を
grepコマンドで出力してください。

シェルスクリプトの変数名には英数字とアンダースコア(_)のみ使用できます。
また、数字で始まる変数名は許容されません。

<details>
<summary>例・解説</summary>

### 例

```bash
$ grep -P "^[a-zA-Z_][0-9a-zA-Z_]*$" ./variable.txt 
# 出力
UNIX
foo_bar
long_variable1234
_
```

ある文字に限定したい場合は、`[]`で表現される文字クラスを使います。
`-`は範囲を指定でき、例では英数字を表現するために利用しています。

先頭が数字でないということから、`[^0-9]`のような否定表現を書きたくなりますが、
使える文字種は制限されているので、多少冗長でも繰り返し記述する必要があります。

### パターン再考

基本オプションは同じなので、ここから、正規表現のみの検証を目的としたgrepコマンドは、
パターンのみを復習していきます。

`^[a-zA-Z_][0-9a-zA-Z_]*$`パターンを再度見直します。
始まりは英字と_に限定(`^[a-zA-Z_]`)し、以降は0文字以上の英数字_の繰り返し(`[0-9a-zA-Z_]*$`)を指定しています。

</details>


## 4. これは日時か

「yyyy/MM/dd HH:mm:ss」形式で表現される日付について検証します。
「date.txt」から、有効な日付形式となっているものをgrepコマンドで出力してください。
日付は以下の条件に従います。

* 年は0~9の任意の数値四桁
* 月は01~12までの数値二桁
* 日は01~31までの数値二桁 閏年などの考慮は除外し、すべての年月で31日まで存在するとみなす
* 時間は00~24までの数値二桁
* 分・秒は00~59までの数値二桁

<details>
<summary>例・解説</summary>

### 例

```bash
$ grep -P "^\d{4}/(0\d|1[012])/([012]\d|3[01]) ([01]\d|2[0-4]):[0-5]\d:[0-5]\d$" ./date.txt
# 出力
1970/01/01 00:00:00
0000/01/01 24:00:59
2020/12/31 09:30:21
```

一見かなり複雑になったように見えますが、シンプルなルールの組み合わせなので、一つ一つ読み解いていけば、
理解できるかと思います。

#### 年

年の部分は制約のない数値の集まりなので、迷うこともないでしょう。
`\d`は数値を表し、`[0-9]`と等価です。
ですので、`\d{4}`は数値4桁を指定しています。

#### 月

少し難しくなってきました。
ルールを書き表してみると、「一桁目が0の場合、二桁目は0~9の数値・一桁目が1の場合、二桁目は0~2の数値」といったようになります。
月はいずれかに合致するはずなので、orに相当する`|`で分岐させると良さそうです。

更に、分岐対象を明確にするため、`()`でグループ化してあげます。
これをパターンで書き出すと、`(0\d|1[012])`となります。

#### 日

分岐は変わりますが、考え方は月と同じです。
同様にルールを書き表すと、「一桁目が0~2の場合、二桁目は0~9の数値・一桁目が3の場合、二桁目は0か1」となります。
更にパターンを書き出すと、`([012]\d|3[01])`の形ができあがります。

#### 時

これまで見たものと同じなので、パターンだけ載せておきます。
`([01]\d|2[0-4])`で「00時~24時」までを表すことができます。

#### 分/秒

分と秒も「00~59秒」までを指す`[0-5]\d`で表せます。

#### 区切り文字

最後に、日時の区切り文字も見ておきましょう。
今回使われたものは、「/」・「 」・「:」の三種類で、いずれもエスケープの必要はないので、そのまま記述できます。


### パターン再考

日付を表すパターンについて、もう一度全体像を見直しておきます。
`^\d{4}/(0\d|1[012])/([012]\d|3[01]) ([01]\d|2[0-4]):[0-5]\d:[0-5]\d$`は、
各要素を、桁数や桁ごとに使える数値を限定しながら記述しています。
量指定子(`{}`)やグループ(`()`)、そして文字クラス(`[]`)やor条件(`|`)を組み合わせ、
それぞれに制約を課しています。

</details>

## 5. 括弧を含めて抜粋(最短一致)

「function.txt」から、括弧「()」で囲まれた文字列を、括弧自体も含めて
grepコマンドで出力してください。

例: function(value)→(value)


<details>
<summary>例・解説</summary>

### 例

```bash
$ grep -Po '\(.*?\)'  ./function.txt 
# 出力
(foo)
(value1, value2)
()
(...args)
```

以降では、合致した箇所のみを抜き出したいので、grepコマンドに新しく
oオプション(only matching)を付与しています。

`.*?`が何を意味するか、理解することが今回の目標です。
`.*`は任意の文字による0回以上の繰り返しを表しています。ここに`?`が来ると、直前の要素の0回または1回の出現を表す
量指定子のように見えます。

しかし、同じ記号であっても、例での`?`は意味することが異なります。
これは正規表現をもとに文字列を探索するとき、最長一致(greedy)/最短一致(lazy)に従うかを示しています。

難しそうな表現となってしまったので、それぞれ簡単に見ていきたいと思います。

---

#### 最長一致

`?`をつけない場合の普段の挙動がこちらに該当します。
最長やgreedyという言葉だけでは難しそうに見えるので、実際の挙動を実験で見てみましょう。

```bash
# echoコマンドの出力結果をパイプでつなぐことで、grepコマンドの入力とできる
# 最長一致で「(」から「)」までを取得
$ echo '(first parenthesis) (second parenthesis) end' | grep -Po '\(.*\)'
# 出力
(first parenthesis) (second parenthesis)
```

後ろの括弧まで取得対象に含まれました。
このように、デフォルトの挙動は、行の最後まで、パターンに合致するものが無いか探しに行きます。
ある分すべてを探しに行く様が強欲(greedy)であることから、このような名前となりました。

#### 最短一致

今回の例はこちらに属します。
量指定子の後ろに`?`を更に書き足すことで、最短一致で探してくれるようになります。
先ほど実験した例を最短一致に切り替えてみましょう。

```bash
$ echo '(first parenthesis) (second parenthesis) end' | grep -Po '\(.*?\)'
# 出力
(first parenthesis)
(second parenthesis)
```

今度はそれぞれの括弧を別々に取得してくれました。
見つかったらそこで諦めて一度探索を打ち切る様が怠惰(lazy)に見えることから、最短やlazyと呼ばれるようです。

[参考](https://www.pcre.org/current/doc/html/pcre2syntax.html#SEC9)

(補足: 最短の意味するところ)

日本語訳の「最短」と聞くと、合致した文字列を可能な限り小さくしてくれるように思えてきます。
例えば、`((string))`に先ほどの最短一致を適用すると、`(string)`が得られるようなイメージです。

しかし、実際に試してみると、

```bash
$ echo '((string))' | grep -Po '\(.*?\)'
# 出力
((string)
```

といったように、`((string)`が抽出されます。
正規表現は、開始地点(`(`)が見つかったらパターンとして収集を始め、終了地点(`)`)が見つかるまで続けます。
ですので、最初の括弧から始まり、最初の閉じ括弧で終了するような挙動をとります。

「最短」で覚えるとやや直感に反してしまうので、lazy、あるいは最左最短などと理解した方がよいかもしれないです。


### パターン再考

最長一致・最短一致は、「探索の打ち切り方」という、これまでに考えてこなかった部分を考慮する必要があったため、
中々に複雑でした。

理解したことを忘れないよう、再度最短一致の表記方法を復習しておきます。
`\(.*?\)`パターンは、まず、括弧自体がグループ化の意味を持つため、`\`でエスケープしておきます。
そして、括弧の中身は何でも良いので、`.*`による任意の文字の0回以上の繰り返しを書き足します。

量指定子である`*`の後ろに`?`を付与することで、最短(lazy)一致に切り替わります。
よって、`\(.*?\)`は、括弧(`(`)から合致させ、括弧閉じ(`)`)で合致を打ち切る、ことを意味します。

</details>

## 6. 中身だけ欲しい(先読み/後読み)

「function.txt」から、括弧「()」で囲まれた文字列を、括弧自体は含めず
grepコマンドで出力してください。

例: function(value)→value

<details>
<summary>例・解説</summary>

### 例

```bash
$ grep -Po '(?<=\().*?(?=\))' ./function.txt 
# 出力
foo
value1, value2
...args
```

括弧など、囲みの中の文字列を取得したい場合は、「先読み/後読み」と呼ばれるパターンを使います。
その表記方法から、量指定子と似たような形に見えますが、全くの別物であることから、やや混乱しやすい挙動をしているので、
じっくりと追っていきます。

#### assertion(言明)

これまでにも出てきた`^`や`$`は、正規表現によるパターンマッチングに制約を課すもので、
「assertion(言明)」と呼ばれます。

例でもう少し掘り下げてみましょう。

`abcdefg`というアルファベットが並んでいる単純な文字列を扱います。
```bash
$ echo 'abcdefg' | grep -Po 'cde'
# cdeが合致した結果として表示される
cde
```

まず、単純な検索では、部分一致検索の動きをしています。

```bash
$ echo 'abcdefg' | grep -Po '^cde'
# 出力なし
```

続いて、`^`記号を書き足すと、結果が変わり、合致しなくなります。

`^`をつければ「~で始まる」条件でマッチングしてくれる、といった理解では、先読み/後読みでつまずいてしまうので、
もう少し考えてみます。

まず、正規表現のパターンマッチングは、正規表現エンジンと呼ばれる機構によって実現されています。
正規表現エンジンの動きを表面だけでも知っておくと、assertionの意味するところが見えてくるかと思います。

ですので、先ほどの例を「正規表現エンジンが処理する流れ」をそれっぽく書いてみます。

---

最初は、単純な部分一致(`cde`)です。
正規表現エンジンは、マッチング対象文字列を一文字ずつ消費し、パターンと合致するか検証していきます。
流れを箇条書きにすると、

* aを消費 aはパターンの先頭cと合致しないので、マッチングを終了
* bを消費 bはパターンの先頭cと合致しないので、マッチングを終了
* cを消費 cはパターンの先頭cと合致する
* dを消費 dはパターンの次の文字列dと合致する
* eを消費 eはパターンの末尾の文字列eと合致する パターンとの合致条件を満たしたので、マッチングを打ち切り

となります。
一文字ずつ読み進めて、パターンと合致するか逐一見ているシンプルな処理なので、直感的に理解できます。

---

続いて、先頭に対するassertionを追加したパターン(`^cde`)を考えます。
同様に流れを書き出してみると、

* `^`を検証 先頭であることから、trueと評価されたので、マッチングを開始 この時点では文字を消費しない
* aを消費 aはパターンの先頭cと合致しないので、マッチングを終了
* 2文字目(b)で同様に`^`を検証 先頭でないことからfalseと評価されたので、マッチング対象外とする
* 3文字目(c)で同様に`^`を検証 先頭でないことからfalseと評価されたので、マッチング対象外とする
* ...
* 行の終端に到達 マッチングの結果、パターンと合致するものが得られなかったので、結果を返さず終了

となります。
assertionにより、正規表現エンジンの処理に制約が加わりました。
trueと評価された場所のみマッチングを実行することは、すなわち、マッチングに位置の制約をもたらすことを意味します。

以上を踏まえれば、パターン`^cde`は、「cdeで始まるものを探してくれる」といった理解から、
「`^`によるassertionにより、先頭でのみパターンマッチングが実行されるため、パターンで始まるもののみが合致する」へと、
更に理解を深めることができるのではないかと思います。

assertionが見えてくると、先読み/後読みの流れがぐっと掴みやすくなるので、
確実に押さえておきましょう。

[参考](https://www.pcre.org/current/doc/html/pcre2pattern.html#SEC20)
[参考2](https://www.regular-expressions.info/lookaround.html)

#### 先読み

先読みはassertionであることから、位置の制約を与えます。
`(?=pattern)`で表現され、直後がパターンを満たしていた場合のみ、trueを返します。
具体的な例で考えます。

```bash
# 出力は無し
$ echo '(abcdefg)hijklmn' | grep -Po '(?=\))'

$ echo '(abcdefg)hijklmn' | grep -Po '.(?=\)).'
# 直後が)であった場合のみ評価されるので、gを消費したとき、2文字取得し、「g)」が得られる
g)
```

a~gまでのアルファベットを括弧で囲み、h~nまで続けていきました。
assertionの項と同様に、パターン`.(?=\)).`について、正規表現エンジンの動きをざっくりと追ってみましょう。

大まかな流れは、`.`で一文字消費し、先読みでassertionを実行します。
そして、assertionがtrueと評価されたときのみ、続けて後続の`.`で一文字消費します。
つまり、一文字ずつ消費しながら、先読みがtrueと評価されたときに、後続の一文字も含めてマッチング結果として取得します。

具体的な流れを書き出すと、

* (を消費 先読みに到達したので、文字を消費せずに次の文字(b)を参照 先読み対象(`)`)ではないのでfalseに評価され、マッチングを停止
* aを消費 先読みに到達したので、文字を消費せずに次の文字(b)を参照 先読み対象(`)`)ではないのでfalseに評価され、マッチングを停止
* ...
* gを消費 先読みに到達したので、文字を消費せずに次の文字(`)`)を参照 先読み対象(`)`)と合致したのでtrueに評価される assertionがtrueと評価されたのでマッチングを続行 次の一文字(`)`)を消費 この結果、`g)`がマッチング結果として得られる
* ...
* 行の終端に到達したので、マッチングを終了

となります。
先読みで次の文字を参照したとき、`(?=パターン)`に記載されたものと合致しているときのみ、trueと評価されます。
今回の場合は、`g`を消費すると、次の文字がパターンに記述された`)`と合致し、trueと評価されたため、更に後続のマッチングも実行されました。
結果として、`)`の前後の文字が得られました。

assertionの動きが見えていれば、先読みの複雑な動きも読めてくるかと思います。

#### 後読み

先読みが直前の位置を返すことが理解できれば、後読みは簡単です。
同じように例を見ると、

```bash
# 出力は無し
$ echo '(abcdefg)hijklmn' | grep -Po '.(?<=\))'

$ echo '(abcdefg)hijklmn' | grep -Po '.(?<=\)).'
)h
```

少し結果が変わっていますね。
後読みがtrueと評価されたところだけ考えてみると、次のようになります。

* `.`により`)`を消費
* 後読み`(?<=\))`により、直前に消費した文字`)`を参照 パターン`)`と合致するので、trueと評価される
* マッチングを続行し、`.`により、hを消費
* マッチングの終端に到達したので、得られた文字列`)h`をマッチング結果として返却

後読みは、読む対象が前になっただけなので、先読みと同様に考えることができます。


#### 括弧の中身

ようやく本題の、括弧の中身を取得する正規表現にたどり着けました。
再度パターンを見返してみましょう。

```bash
$ grep -Po '(?<=\().*?(?=\))' ./function.txt 
# 出力
foo
value1, value2
...args
```

`(`は後読み・`)`は先読みが使われています。
ですので、`(`の次の文字列が消費されたときに後読みはtrueと評価され、`)`の前の文字列が消費されたときに
先読みはtrueと評価されます。

つまり、`(`の次の文字列からマッチングが開始し、`(`の前の文字列で終了します。
更に言い換えれば、`()`の中身の文字列のみをマッチング対象とするので、括弧の中身の文字列が得られます。

また、最短一致`?`を記述することで、量指定子`*`が更に右側に存在する別の`)`を探すことを抑止してくれます。


#### パターン再考

位置の制約を加えたマッチングは、これまでに無いものでかつ、抽象的で中々掴みにくいものなので、
もう少し考えてみましょう。
`(?<=\()`は、`(`に対する後読みで、直前に消費した文字列が`(`だった場合のみtrueと評価されます。
同様に、`(?=\))`は、`)`に対する先読みで、直後に消費する文字列が`)`だった場合のみtrueと評価されます。

`^.*$`と書くと、先頭の位置から末尾の位置までの範囲で、すべての文字列を取得するので、マッチング行全体が得られます。
同じように考えると、`(?<=\().*(?=\))`は、括弧開始の直後の位置から、括弧閉じの直前の位置までの範囲で、すべての文字列を取得します。
これは、言い換えれば、「括弧の中身」となります。
更に、複数の括弧が存在しても、別々に取得できるよう、最短一致`?`を加えれば、完成です。

</details>

## 7. JavaScriptじゃなくて、Javaが欲しい(否定先読み)

ブログアプリに検索機能をつけようと思ったとき、部分一致検索では、`Java`と検索すると、
`JavaScript`もヒットします。これはまずい予感がするので、
「Java_JavaScript.txt」から、Javaに関する行のみ抜き出してください。

例:

* Javaの話です→対象
* JavaScriptの話です→対象外

<details>
<summary>例・解説</summary>

### 例

```bash
$ grep -P 'Java(?!Script)' ./Java_JavaScript.txt 
# 出力
ここではJavaの話をしています。
JavaにScriptletってありませんでしたっけ。そうでした、JSPでしたね。
JavaとJavaScriptの違いを教えてください。
REPL的なScriptJavaは存在するのでしょうか
```

最後の例では、否定先読みが肝となります。
先読み/後読みのときと同様、否定先読みもassertionなので、いつtrueと評価されるかを意識しながら、
しっかり把握していきましょう。

#### 否定先読み

プログラミング言語ではお馴染みの`!`をつけることで、先読み/後読みを否定することができます。
否定した結果、trueと評価される条件は、先読み/後読みの逆となります。

否定による反転は字面で考えていると混乱してくるので、実際の動きを見てみましょう。
`abcdefg`の文字列で、否定先読み`(?!c)`によるマッチングを例で考えます。

```bash
# 否定先読みも文字を消費しないので、単体では出力なし
$ echo 'abcdefg' | grep -Po '(?!c)'
# bを消費したときのみ、次の文字列がcとなり、否定先読みでfalseと評価されるので、b以外が合致
$ echo 'abcdefg' | grep -Po '.(?!c)'
a
c
d
e
f
g
# cを消費するときのみ、次の文字列がcとなり、否定先読みでfalseと評価されるので、c以外が合致
$ echo 'abcdefg' | grep -Po '(?!c).'
a
b
d
e
f
g
```

先読みでは、前後に`.`を記述すると、1文字しか得られませんでした。
一方、否定先読みでは、前後の1文字以外が得られました。

これは、否定先読みがいつtrue/falseで評価されるか考えると見えてきます。
否定先読みは、「次に消費する文字列がパターンと合致していた場合のみ」falseと評価されます。
言ってしまえば、否定先読みは、先読みと真偽値が逆転しています。

ただ逆転しているだけだということが分かれば、否定先読み/後読みも掴めてくるのではないかと思います。

#### JavaScriptを除外して、Javaだけが欲しい

ブログアプリでもWebアプリケーションでも、検索はよく使われる機能です。
ものによって色々と事情は異なりますが、技術ブログで`Java`を検索したときに、`JavaScript`の記事も
対象となると、いまいち使いにくく感じてしまいます。

このように、「特定の条件は除外したい」ときには、否定先読みがとても便利です。
パターンを見返してみましょう。

```bash
$ grep -P 'Java(?!Script)' ./Java_JavaScript.txt 
# 出力
ここではJavaの話をしています。
# ...
```

否定先読みは、消費した文字の先の文字を読み進め、指定したパターンに合致したとき、falseに評価されます。
文字列`JavaScript`が含まれる場合は、条件を満たし、assertionがfalseと評価されるので、マッチング対象外となります。

以上より、`Java`と`JavaScript`を区別して検索できるようになりました。


</details>

## まとめ

具体的な問題を解きながら、正規表現の概要に触れていきました。
基本から押さえていけば、一見記号の羅列にしか見えないパターンも読み解けるようになるのではないかと思います。

もっと良い問題の案などございましたら、Issue等頂けるとうれしいです。